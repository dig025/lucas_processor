// message to be encypted will be stored at mem[0:53]
//encrypted message

//setup:
  is  0      
  fig r3      //r3 = 0 loop counter
  is  64       
  fig r4      //r4 = 64 max loop itr
  is  61
  fig r5      //r5 = 61 mem loc of number of spaces/preamble
  is  62      
  fig r6      // r6 = 62 mem loc of tap sequence
  lb  r2 r6   // r2 = mem[r6]
  is  0
  fig r1      // r1 = 0
  add r6      // r6 = r2 + r1
  is  63
  fig r7      // r7 = 63 mem loc of start state for lfsr
  lb  r2 r7    // r2 = mem[r7]
  is  0       
  fig r1      // r1 = 0
  add r7      // r7 = mem[r7] + 0
  is  64      
  fig r8      // r8 = 64 where to start writing instructions

  // space char preamble to mem
  // checking if num spaces is less than 10
  lb  r1 r5     // r1 = number of spaces
  is  10        // r0 = 10
  fig r2        // f2 = 10
  slt r15       // r15 = 1 if num_spaces < 10, 0 otherwise
  fgo r15 r1    // r1 = result of comparison in r15
  is  0         // r0 = 0
  fig r2        // r2 = 0
  is  6         // skip to check if num_spaces > 26
  beq r0        // branch to check if num_spaces > 26
  is  10        // r0 = 10
  fig r5        // r5 = 10 (var holding the num of spaces to encrypt)
  is  0         // r0 = 0 
  fig r1        // this branch will always be true
  fig r2        // this branch will always be true
  beq // skip to after the num_spaces = 26
  // checking if num_spaces > 26
  lb  r1 r5     // r1 = number of spaces
  is  26        // r0 = 26
  fig r2        // r2 = 26
  slt r15       // r15 = 1 if num_spaces < 26, 0 otherwise
  fgo r15 r1    // r1 = result of comparison in r15
  is  1         // r0 = 1
  fig r2        // r2 = 1
  is  8         // the number of instructions after setting num_spaces = 26
  beq r0        // branch to "after setting num_spaces = 26"
  is  26        // r0 = 26
  fig r5        // r5 = 26 (var holding the num of spaces to encrypt)
  is  0
  fig r1
  fig r2
  is  4         // number of instructions to encryption logic
  beq r0        // branch to encryption logic
  // setting num_spaces to what was in memory location
  lb  r1 r5     // r1 = number of spaces in memory location
  is  0         // to get content of r1 into r5
  fig r2        // r2 = 0 
  add r5        // r5 = r1 (number of spaces in mem location)

  // encryption logic AT THIS POINT R5 CONTAINS NUM_SPACES
  fgo r3 r1     // loop counter (r3) inside r1
  fgo r5 r2     // num_spaces (r5) inside r2
  slt r15       // r15 = 1 if r1 < r2, otherwise r15 = 0
  fgo r15 r1    // r1 = r15 the result of comparison
  is  0         // r0 = 0
  fig r2        // r2 = 0 
  beq // branch to else
  // if statement - code to encrypt spaces
  is  0x20      // space char
  fig r1        // r1 = 0x20
  fgo r7 r2     // r2 = state in r7
  xor r15       // r15 = xor 
  fgo r15 r1    // r1 = r15 (result of xor) aka: encrypted char
  is  0x7F      // ignoring the MSB
  fig r2        
  and r14       // r15 stores encrypted char with MSB = 0 
  is  1         
  fig r1
  fig r2
  is  7
  beq r0        // skip to initial condition check for while(encrypted)
  
  // else statement - code to encrypt from mem
  lb  r1  r3    // read char from  R[r1] = mem[r3]
  fgo r7  r2    // state in r7
  xor r15       // encrypts before adding parity bit
  fgo r15  r1   // r1 = r15 (result of xor) aka:encrypted char
  is  0x7F      
  fig r2
  and r14       // r14 stores encrypted char with MSB = 0

  // initial condition check for while(encrypted)
  is  0
  fig r2        // r2 = 0
  fig r13       // r13 = 0 (parity bit initialization)
  fgo r14  r1   // r1 = encrypted
  is  17        (17 for how many instructions after pc+1)
  beq r0        //to after while loop for encrypted

  // actual parity bit calculation
  fgo r13  r1   // r1 = r13 (parity)
  is  1         
  fig r2        // r2 = 1
  xor r13       // r13 = r13 ^ 1

  // decrement and condition check
  is  -1
  fig r2        // r2 = -1
  fgo r14  r1   // r1 = encrypted
  add r14       // r14 = encrypted - 1
  fgo r14  r1   
  is  0
  fig r2        // r2 = 0
  is  3 
  beq r0        //to after while loop for encrypted because encrypted=0
  fig r1        // r1 = 0
  is  -16
  beq r0        //because 0=0, branch to beginning of while(encrypted)
  
  // left shifting parity bit by 7 to fit encrypt char
  fgo r13  r1   // r1 = r13 (parity)
  is  7
  fig r2        // r2 = 7
  sll r13       // r13 = r13 << 7
  // and masking encrypted message to make MSB = 0
  fgo r14  r1   // r1 = r14
  is  0x7F
  fig r2        // r2 = 0x7F
  and r15       // r15 = r14 & 0x7F
  // encrypted message with parity bit r15
  fgo r13  r1   // r1 = r13
  fgo r15  r2   // r2 = r15
  or  r15       // r15 = r15 | r13
  // storing message into data mem and incrementing location
  fgo r15  r1   // r1 = 15
  sb  r1   r8   // mem[r8] = r1
  fgo r8   r1   // r1 = r8
  is  1        
  fig r2        // r2 = 1
  add r8        // r8 = r8 + 1

  // creating next state for while(ones)
  fgo r7  r1    // r1 = r7 (state)
  fgo r6  r2    // r2 = r6 (tap)
  and r14       // ones = state & taps (r14 = r6 & r7)
  fgo r7  r1    
  is  1
  fig r2
  sll r7       // r7 = r7 << 1
  is  0
  fig r13      // r13 = lsb for new state (bit)
  
  // initial condition check for while(ones)
  is  0
  fig r2        // r2 = 0
  fgo r14  r1   // r1 = ones
  is  16
  beq r0        //to after while(ones)
  
  // start of while ones
  fgo r13  r1
  is  1
  fig r2
  xor r13     // r13 = r13 ^ 0x01
  // decrement and condition check
  is  -1
  fig r2        // r2 = -1
  fgo r14  r1   // r1 = ones
  add r14       // r14 = ones - 1
  fgo r14  r1   
  is  0
  fig r2        // r2 = 0
  is  3   
  beq r0        //to after while loop for ones because ones=0
  fig r1        // r1 = 0
  is  -16
  beq r0        //because 0=0, branch to beginning of while(ones)

  // after while(ones) we set the bit for the new state
  fgo r7  r1    // r1 = r7 (state)
  is  0x7E
  fig r2
  and r7        // r7 = state & 0x7E
  fgo r7  r1    
  fgo r13 r2    // r2 = r13 (bit)
  or  r7        // r7 = r7 | bit

  // for incrementing for loop for char_read
  is  1         
  fig r2       // r2 = 1
  fgo r3   r1   // r1 = r3 (loop counter) 
  add r3        // r3 = r3 + 1  
  fgo r3   r1   // r1 = r3
  fgo r4   r2   // r2 = r4 (the max loop iteration)
  slt r15       // r15 = 1 if r1 < r2, 0 otherwise
  fgo r15  r1   // r1 = r15
  fig r2        // r2 = 1
  is  // how many instructions
  beq r0